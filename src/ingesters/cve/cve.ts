import { CPE } from "../cpe/type.ts";
import { Batcher, SimpleBatcher } from "./../../utils/batcher.ts";
import { prepareDate } from "./../../utils/format.ts";
import { Persistor } from "./../../utils/persistor.ts";
import { Counter, PoolExecutor, sleep, toMs } from "./../../utils/pool.ts";
import {
  BaseCVESearch,
  CveChunk,
  CVENVD,
  CVENVDResult,
  CVESearch,
  Update,
} from "./../../utils/types.ts";
import { getDateChunks } from "./../../utils/utils.ts";
import {
  handleCWE,
  handleDescription,
  handleReferences,
  handleV2Metrics,
  handleV3Metrics,
  makeBase
} from "./format.ts";
import { UpdateProps } from "./type.ts";
import apikey from "../../../../apikey.json" assert { type: "json" };
export const defaultValues = {
  cwe: "Unknown",
};

// The value is based on the maximum possible for the API given by NVD
const pageSize = 2000;

async function getCvesBetweenPaged(
  page: number,
  initiatePersistance: boolean,
  start?: Date,
  end?: Date
): Promise<CVENVDResult> {
  const startIndex = page * pageSize;
  let url = ""
  // We want to update our existing database
  if (!initiatePersistance && start && end) {
    const startString = prepareDate(start);
    const endString = prepareDate(end);
    url = `https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=${startString}&lastModEndDate=${endString}&startIndex=${startIndex}`;
  }
  // We want to initiate our Database
  else {
    url = `https://services.nvd.nist.gov/rest/json/cves/2.0?startIndex=${startIndex}`;
  }
  // Keep trying until we get a parsable answer
  for (; ;) {
    try {
      const res = await fetch(url, { method: 'GET', headers: apikey});
      await sleep(toMs(600));
      const text = await res.text();
      if (res.status != 200) {
      console.log(`warn: got status ${res.statusText}`);
      await sleep(toMs(6_000));
      } else {
        try {
          const value = JSON.parse(text);
          console.log(`could get good answer for index ${startIndex}`)
          return value;
        } catch (_e) {
          console.error(res.status, text);
          // throw e;
        }
      }
    } catch (e) {
      console.error(" --------------------------------------------------------------------------\n--------------------------------------------------------------------------\nError fetching", e);
    }
  }
}

// in Days, arbitrary value
const timeChukSize = 30;

/**
 * Gives the values that we got from the NVD API to the batcher in order to get persisted
 * @param initiatePersistance boolean to know if we persist everything of simply update
 * @param baseStart if we update, start date of the update
 * @param baseEnd if we update, end date of the update
 * @returns a Chunk
 */
async function* getCvesBetween(
  initiatePersistance: boolean,
  baseStart?: Date,
  baseEnd?: Date,
): AsyncGenerator<CveChunk> {
  // We create timeChunkSize Chunks to get so that we make smaller requests which are easier to handle by the network
  if (!initiatePersistance && baseStart && baseEnd) {
    for (const [start, end] of getDateChunks(baseStart, baseEnd, timeChukSize)) {
      let hasRemaining = true;
      let page = 0;

      while (hasRemaining) {
        // Modified for test purposes
        const result = await getCvesBetweenPaged( page, initiatePersistance, start, end);
        // if the result is exactly the size of the page then we waste one query
        hasRemaining = (result.vulnerabilities.length >= pageSize);
        const expectedPages = result.totalResults / pageSize;
        page++;
        yield { result, page, expectedPages, start, end, hasRemaining };
      }
    }
  } else {
    // We get all the values split into several pages if necessary by the NVD API
    console.log("Doing all the CVEs existing");
    let hasRemaining = true;
    let page = 0;
    
    while (hasRemaining) {
      const result = await getCvesBetweenPaged(page, initiatePersistance);
      // if the result is exactly the size of the page then we waste one query
      hasRemaining = (result.vulnerabilities.length >= pageSize);
      const expectedPages = result.totalResults / pageSize;
      page++;
      yield { result, page, expectedPages, hasRemaining };
    }
  }
}

/**
 * Gives the values that we got from the NVD API to the batcher in order to get persisted
 * @param chunk chunk to be persisted which contains the CVEs to persist, the page number and the expected pages number
 * @param counter counter used for logs
 * @param batcher batcher that will persist values
*/
async function doOnePage(
  chunk: CveChunk,
  counter: Counter,
  batcher: Batcher<unknown>,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
) {
  const {
    result,
    page,
    expectedPages
  } = chunk;
  console.log("doing page", page, "of expected pages", expectedPages);
  const start = new Date().getTime();
  // add streaming here maybe
  const re = result.vulnerabilities
  .map((c) =>
    handleOne(c.cve, handleCPE)
    .then((e) => {
      // Pas besoin de ça vu qu'on fait tout à la suite (en soit aujourd'hui vu comment ça marche, il faut enqueue pour qu'ensuite le flush, il aille chercher les éléments pour bien les rajouter dans la DB)
      batcher.enqueue(e);
      counter.increment();
          })
        );
  await Promise.all(re);
  const end = new Date().getTime();
  const took = (end - start) / 1000;
  console.log(`page ${page} took ${took} s`);
}

  /**
   * Gets the information from the item and outputs the cve with the right format to be handled by the persistor
   * @param item CVE from the API to format
   * @returns CVE formatted from item
   */
async function handleOne(
  item: CVENVD,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
): Promise<BaseCVESearch> {
  const cve = makeBase(item);
  handleDescription(item, cve);
  handleV3Metrics(item, cve);
  handleV2Metrics(item, cve);
  handleReferences(item, cve);
  handleCWE(item, cve);

  await handleCPE(item, cve);

  return {
    ...cve
  };
}

// This value should never be used
const EARLIEST_DATE = new Date("01-01-1980");

/**
 * Main function Gets all the CPEs from the NVD API and then submits them to a pool that has to give them to the batcher that will persist the CPEs to the database
 * @param batcher batcher that uses the persistor
 * @param persistor persistor that does the right PostreSQL queries
 * @param pool pool that sends CPEs to the batcher
 * @param updatePersistor persistor that validates in the database the update
 */
export class CVEIngester {
  protected readonly cvePersistor: Persistor<BaseCVESearch, { id: string }>;
  protected readonly cpePersistor: Persistor<CPE, { id: string }>;
  protected readonly updatePersistor: Persistor<
    Update,
    string
  >;

  constructor(
    cvePersistor: Persistor<BaseCVESearch, { id: string }>,
    cpePersistor: Persistor<CPE, { id: string }>,
    updatePersistor: Persistor<Update, string>,
  ) {
    this.cvePersistor = cvePersistor;
    this.cpePersistor = cpePersistor;
    this.updatePersistor = updatePersistor;
  }

  populateCves = async (props?: UpdateProps) => {
    const counter = new Counter();
    const upTo = new Date();
    // We get the date of last update from the database 
    const dbLastUpdate = await this.updatePersistor.findOne("CVE");
    console.log(`Last CVE update done : ${dbLastUpdate?.last_update}`);
    const initiatePersistance = (dbLastUpdate?.last_update == null);

    const pool = new PoolExecutor(1);
    const batcher = new SimpleBatcher(2000, this.flusher, pool);
    const start = new Date().getTime();
    // We iterate on all our results and submit them to be persisted. 
    // !(dbLastUpdate) is InitiatePersistance, if true we need to get all the CVEs, if false we update the db
    for await (const r of getCvesBetween( initiatePersistance, dbLastUpdate ? dbLastUpdate.last_update : EARLIEST_DATE, upTo)) {

      pool.submit(() =>
        doOnePage(r, counter, batcher, this.handleCPE)
    );
    
    await pool.isEmpty();
    await batcher.flush();
  }
    console.log("all download done, waiting for handlers to finish");
    // We wait for the pool to have submitted all the CVEs to the batcher to be persisted
    await pool.isEmpty();
    
    await batcher.flush();

    const end = new Date().getTime();
    const took = (end - start) / 1000;

    console.log(`done: ${counter.get()} in ${took} s`);
    console.log(`did ${counter.get() / took} items/s`);

    // Once done, we validate the last update using our upTo value which is when we started fetching from the NVD
    await this.updatePersistor.persistOne({
      id: 2,
      last_update: upTo,
      name: "CVE",
    });
  };


    /**
   * Called when a batcher is flushed with the batch being flushed
   * @param batch
   * @returns
   */
  protected flusher = async (batch: BaseCVESearch[]) => {
    const size = batch.length;
    if (size === 0) {
      return;
    }
    const start = new Date().getTime();
    const batchInsertResult = await this.cvePersistor.persistMany(batch);

    const end = new Date().getTime();
    console.log("batch insert took", end - start, "for", batchInsertResult);
  };

    /**
   * Adds the configuration inside the cve object in order to link cpes and cves
   * @param item the json from nvd with the configuration
   * @param cve the cve to nourish
   * @returns
   */
  handleCPE = async (item: CVENVD, cve: CVESearch) => {
    if (cve.matches === undefined) {
      cve.matches = [];
    } 
    if ("configurations" in item) {
      for (const i of item.configurations.flatMap((e) => e.nodes)) {
        if (!Array.isArray(i.cpeMatch)) {
          console.error("error", i, item.id, item.configurations);
          continue;
        }
        for (const cpeMatch of i.cpeMatch) {
            cve.matches.push(cpeMatch);
        }
      }
    }
  };
}
