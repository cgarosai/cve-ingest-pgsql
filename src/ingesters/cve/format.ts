import { CVENVD, CVESearch, SetKeys } from "../../utils/types.ts";
import { formatDate, sha1Hex } from "./../../utils/format.ts";
import { defaultValues } from "./cve.ts";
import { CpeMatch } from "./type.ts";

export function stem(cpeUri: string) {
  const cpeArr = cpeUri.split(":");
  const i = cpeArr.slice(0, 5);
  return i.join(":");
}

/**
 * Extracts the CWE and binds it to the cveSearch Side
 * @param cveNVD
 * @param cveSearch
 */
export function handleCWE(cveNVD: CVENVD, cveSearch: CVESearch) {
  let localCWE = defaultValues.cwe;
  if ("weaknesses" in cveNVD) {
    // only take primary for now
    for (const i of cveNVD.weaknesses.filter((e) => e.type === "Primary")) {
      for (const values of i.description) {
        if (values.lang === "en") {
          localCWE = values.value;
        }
      }
    }
  }
  cveSearch.cwe = localCWE;
}

function selectCvssMetricsV2(item: CVENVD) {
  return item.metrics.cvssMetricV2[0];
}

function selectCvssMetricsV3(item: CVENVD) {
  return item.metrics.cvssMetricV31[0];
}

export function handleV2Metrics(item: CVENVD, cve: CVESearch) {
  cve["access"] = {};
  cve["impact"] = {};
  cve["cvss"] = null;
  if ("cvssMetricV2" in item.metrics) {
    const v2 = selectCvssMetricsV2(item);
    const data = v2.cvssData;
    cve["access"] = {
      authentication: data.authentication,
      complexity: data.accessComplexity,
      vector: data.accessVector,
    };
    cve["impact"] = {
      availability: data.availabilityImpact,
      confidentiality: data.confidentialityImpact,
      integrity: data.integrityImpact,
    };
    cve["cvss"] = data.baseScore;
    cve["exploitabilityScore"] = v2.exploitabilityScore;
    cve["impactScore"] = v2.impactScore;
    cve["cvss_time"] = new Date(item.lastModified);

    // # NVD JSON lacks the CVSS time which was present in the original XML format
    cve["cvss_vector"] = data.vectorString;
  }
}

export function handleReferences(item: CVENVD, cveSearch: CVESearch) {
  cveSearch["references"] = item?.references.map((e) => e.url);
}

export function handleV3Metrics(item: CVENVD, cve: CVESearch) {
  if ("cvssMetricV31" in item.metrics) {
    const v3 = selectCvssMetricsV3(item);
    const data = v3.cvssData;
    cve["impact3"] = {
      availability: data.availabilityImpact,
      confidentiality: data.confidentialityImpact,
      integrity: data.integrityImpact,
    };
    cve["exploitability3"] = {
      attackvector: data.attackVector,
      attackcomplexity: data.attackComplexity,
      privilegesrequired: data.privilegesRequired,
      userinteraction: data.userInteraction,
      scope: data.scope,
    };
    cve["cvss3"] = data.baseScore;
    cve["cvss3_vector"] = data.vectorString;
    cve["impactScore3"] = v3.impactScore;
    cve["exploitabilityScore3"] = v3.exploitabilityScore;
  }
}

export function addIfMissing(cve: CVESearch, key: SetKeys, value: string) {
  const e = cve[key];
  e.add(value);
}

export function makeQueryId(criteria: string, versionInfo: string) {
  return sha1Hex(criteria + versionInfo);
}

export function extractVendorAndProduct(cpe_uri: string) {
  const vendor = cpe_uri.split(":")[3];
  const product = cpe_uri.split(":")[4];
  return [vendor, product];
}

export function handleDescription(cveNVD: CVENVD, cveSearch: CVESearch) {
  for (const description of cveNVD.descriptions) {
    if (description["lang"] == "en") { // only take english descriptions
      if ("summary" in cveSearch) {
        cveSearch["summary"] += ` ${description["value"]}`;
      } else {
        cveSearch["summary"] = description["value"];
      }
    }
  }
}

export function makeBase(c: CVENVD) {
  return {
    id: c.id,
    assigner: c.sourceIdentifier,
    "Published": formatDate(new Date(c.published)),
    "Modified": formatDate(new Date(c.lastModified)),
    last_modified: formatDate(new Date(c.lastModified)),
    status: c.vulnStatus,
    vulnerable_configuration: new Set<string>(),
    vulnerable_product: new Set<string>(),
    vendors: new Set<string>(),
    products: new Set<string>(),
    vulnerable_product_stems: new Set<string>(),
    vulnerable_configuration_stems: new Set<string>(),
    cwe: defaultValues.cwe,
  } as unknown as CVESearch;
}

// deno-lint-ignore require-await
export async function prepareQuery(
  cpeuri: CpeMatch,
): Promise<[Record<string, unknown> | undefined, string]> {
  // deno-lint-ignore no-explicit-any
  const query: any = {};
  let version_info = "";
  if ("versionStartExcluding" in cpeuri) {
    query.versionStartExcluding = cpeuri.versionStartExcluding;
    version_info += query.versionStartExcluding + "_VSE";
  }

  if ("versionStartIncluding" in cpeuri) {
    query.versionStartIncluding = cpeuri.versionStartIncluding;
    version_info += query.versionStartIncluding + "_VSI";
  }

  if ("versionEndExcluding" in cpeuri) {
    query.versionEndExcluding = cpeuri.versionEndExcluding;
    version_info += query.versionEndExcluding + "_VEE";
  }

  if ("versionEndIncluding" in cpeuri) {
    query.versionEndIncluding = cpeuri.versionEndIncluding;
    version_info += query.versionEndIncluding + "_VEI";
  }
  if (Object.keys(query).length > 0) {
    return [query, version_info];
  } else {
    return [undefined, version_info];
  }
}
