import { Batcher, SimpleBatcher } from "./../../utils/batcher.ts";
import { prepareDate, formatDate } from "./../../utils/format.ts";
import { Persistor } from "./../../utils/persistor.ts";
import { MATCHING } from "../matching/type.ts";
import { Counter, PoolExecutor, sleep, toMs } from "../../utils/pool.ts";
import { getDateChunks } from "../../utils/utils.ts";
import { UpdateProps } from "../cve/type.ts";
import apikey from "../../../../apikey.json" assert { type: "json" };
import { MatchingChunk, MATCHINGNVD, Update, MATCHINGSearch, MATCHINGNVDResult } from "../../utils/types.ts";

// The value is based on the maximum possible for the API given by NVD
const pageSize = 500;


/**
 * Makes the queries to the NVD API based on params 
 * @param page page number to fetch
 * @param pageSize maximum size of page to fetch
 * @param initiatePersistance boolean to know if we persist everything of simply update
 * @param start if we update, start date of the update
 * @param end if we update, end date of the update
 * @returns Matchings from the API as json
 */
async function getMatchingsBetweenPaged(
  page: number,
  initiatePersistance: boolean,
  start?: Date,
  end?: Date,
): Promise<MATCHINGNVDResult> {
  let url = "";
  const startIndex = page * pageSize;
  let counter = 0; 
  // We want to update our existing database
  if (!initiatePersistance && start && end) {
  
    const startString = prepareDate(start);
    const endString = prepareDate(end);
    url = `https://services.nvd.nist.gov/rest/json/cpematch/2.0?lastModStartDate=${startString}&lastModEndDate=${endString}&startIndex=${startIndex}`;
  // We want to initiate our Database
  } else {
    url = `https://services.nvd.nist.gov/rest/json/cpematch/2.0?startIndex=${startIndex}`;
  } 
  // Keep trying until we get a parsable answer
  for (; ;) {
    try {
      const res = await fetch(url, { method: 'GET', headers: apikey});
      
      if (res.status != 200) {
        counter += 1;
        console.log(`warn: got status ${res.statusText}`);
        await sleep(toMs(1000*counter*counter));
      } else {
        try {
          const value = await res.json();
          return value;
        } catch (_e) {
          console.error(res.status);
          // throw e;
        }
      }
    } catch (e) {
      console.error(" --------------------------------------------------------------------------\n--------------------------------------------------------------------------\nError fetching", e);
      await sleep(toMs(6_000));
    }
  }
}

// in Days, arbitrary value
const timeChukSize = 30;

/**
 * Gives the values that we got from the NVD API to the batcher in order to get persisted
 * @param initiatePersistance boolean to know if we persist everything of simply update
 * @param baseStart if we update, start date of the update
 * @param baseEnd if we update, end date of the update
 * @returns a Chunk
 */
async function* getMatchingsBetween(
  initiatePersistance: boolean,
  baseStart: Date,
  baseEnd: Date,
): AsyncGenerator<MatchingChunk> {
  // We create timeChunkSize Chunks to get so that we make smaller requests which are easier to handle by the network
  if (!initiatePersistance && baseStart && baseEnd) {
    for (const [start, end] of getDateChunks(baseStart, baseEnd, timeChukSize)) {
      console.log(`Doing MATCHINGs between ${start} and ${end}`);
      let hasRemaining = true;
      // reprendre page 815 si test positif
      let page = 0;

      while (hasRemaining) {
        const result = await getMatchingsBetweenPaged(page, initiatePersistance, start, end);
        // if the result is exactly the size of the page then we waste one query
        hasRemaining = (result.matchStrings.length >= pageSize);
        const expectedPages = result.totalResults / pageSize;
        page++;
        yield { result, page, expectedPages, start, end, hasRemaining };
      }
    }
  } else {
    // We get all the values split into several pages if necessary by the NVD API
    console.log("Doing all the Matchings existing");
    let hasRemaining = true;
    let page = 0;
    
    while (hasRemaining) {
      const result = await getMatchingsBetweenPaged(page, initiatePersistance);
      // if the result is exactly the size of the page then we waste one query
      hasRemaining = (result.matchStrings.length >= pageSize);
      const expectedPages = result.totalResults / pageSize;
      page++;
      yield { result, page, expectedPages, hasRemaining };
    }
  }
}

/**
 * Gives the values that we got from the NVD API to the batcher in order to get persisted
 * @param chunk chunk to be persisted which contains the Matchings to persist, the page number and the expected pages number
 * @param counter counter used for logs
 * @param batcher batcher that will persist values
 */
async function doOnePage(
  chunk: MatchingChunk,
  counter: Counter,
  batcher: Batcher<unknown>,
) {
  const {
    result,
    page,
    expectedPages,
  } = chunk;
  console.log("doing page", page, "of expected pages", expectedPages);
  const re = result.matchStrings
    .map((c) =>
      handleOne(c.matchString)
        .then((e) => {
          batcher.enqueue(e);
          counter.increment();
        })
    );
  await Promise.all(re);
}

  /**
   * Gets the information from the item and outputs the cpe with the right format to be handled by the persistor
   * @param item Matching from the API to format
   * @returns CPE formatted from item
   */
async function handleOne(
  item: MATCHINGNVD
  ): Promise<MATCHINGSearch> {
  try {
    const matching = {
      matchCriteriaId: item.matchCriteriaId,
      criteria: item.criteria,
      created: formatDate(new Date(item.created)),
      lastModified: formatDate(new Date(item.lastModified)),
      cpeLastModified: formatDate(new Date(item.cpeLastModified)),
      status: item.status,
      matches: item.matches,
    }
    return (matching);
  }
  // The cpeLastModified field does not exist for all the matchings therefore, we put in the lastModifed field
  catch (e) {
    const matching = {
      matchCriteriaId: item.matchCriteriaId,
      criteria: item.criteria,
      created: formatDate(new Date(item.created)),
      lastModified: formatDate(new Date(item.lastModified)),
      cpeLastModified: formatDate(new Date(item.lastModified)),
      status: item.status,
      matches: item.matches,
    }
    return (matching);
  }
  
}

// This value should never be used
const EARLIEST_DATE = new Date("01-01-1980");

/**
 * Main function Gets all the Matchings from the NVD API and then submits them to a pool that has to give them to the batcher that will persist the Matchings to the database
 * @param batcher batcher that uses the persistor
 * @param persistor persistor that does the right PostreSQL queries
 * @param pool pool that sends Matchings to the batcher
 * @param updatePersistor persistor that validates in the database the update
 */
export class MATCHINGIngester {
  protected batcher: SimpleBatcher<MATCHING>;
  protected persistor: Persistor<MATCHING, { id: string }>;
  protected pool: PoolExecutor;
  protected updatePersistor: Persistor<Update, string>;
  constructor(
    persistor: Persistor<MATCHING, { id: string }>,
    updatePersistor: Persistor<Update, string>,
  ) {
    this.pool = new PoolExecutor(1);
    // The size of the batcher is arbitrary
    this.batcher = new SimpleBatcher<MATCHING>(5000, this.flusher, this.pool);
    this.persistor = persistor;
    this.updatePersistor = updatePersistor;
  }
  populateMatchings = async (props?: UpdateProps) => {
    const counter = new Counter();
    const upTo = new Date();
    // We get the date of last update from the database 
    const dbLastUpdate = await this.updatePersistor.findOne("MATCH");
    console.log(`Last MATCHING update done : ${dbLastUpdate?.last_update}`);
    const initiatePersistance = (dbLastUpdate?.last_update == null);
    const start = new Date().getTime();
    // We iterate on all our results and submit them to be persisted. 
    // !(dbLastUpdate) is InitiatePersistance, if true we need to get all the Matchings, if false we update the db
    for await (const r of getMatchingsBetween(initiatePersistance, dbLastUpdate ? dbLastUpdate.last_update : EARLIEST_DATE, upTo)) {
      this.pool.submit(() =>
        doOnePage(r, counter, this.batcher)
      );
      // After sending one page, we wait for the page to end so that there is no desynchronisation between the fetching from NVD and persisting in our DB
      await this.batcher.flush();
    }
    console.log("all download done, waiting for handlers to finish");
    await this.pool.isEmpty();

    await this.batcher.flush();

    const end = new Date().getTime();
    const took = (end - start) / 1000;

    console.log(`done: ${counter.get()} in ${took} s`);
    console.log(`did ${counter.get() / took} items/s`);

    // Once done, we validate the last update using our upTo value which is when we started fetching from the NVD
    await this.updatePersistor.persistOne({
      id: 3,
      last_update: upTo,
      name: "MATCH"
    });
  }

  /**
   * Called when a batcher is flushed with the batch being flushed
   * @param batch
   * @returns
   */
  protected flusher = async (batch: MATCHING[]) => {
    const size = batch.length;
    if (size === 0) {
      return;
    }
    console.log("doing batch");
    const start = new Date().getTime();
    const batchInsertResult = await this.persistor.persistMany(batch);

    const end = new Date().getTime();
    console.log("batch insert took", end - start, "for", batchInsertResult);
    console.log("--------------------------------------------------------------------------")
  };
}