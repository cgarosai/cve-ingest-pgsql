// @ts-ignore
import { Client } from "https://deno.land/x/postgres@v0.17.1/mod.ts";
import { formatDate } from "./format.ts";
import { CPESearch, BaseCVESearch, MATCHINGSearch } from "./types.ts";

export interface Persistor<
  T,
  Identifier, // should add constraint on > Identifier part of T
> {
  /**
   * Find the first item corresponding to the criteria
   * <p>
   * Can only be found by the identifier
   * @param i
   */
  findOne(i: Identifier): Promise<T | undefined>;
  persistOne(items: T): Promise<boolean>;
  persistMany(items: T[]): Promise<number>;
  open(): Promise<void>;
  close(): Promise<void>;
}

// deno-lint-ignore ban-types
type Obj = {};

type UpdateSchema =  Obj & {id: number, last_update: Date};

// ADDITION //

  // TODO : Rename PersistorFactory
  export interface PgPersistorFactory {
    make<Schema extends Obj, Identifier extends Obj>(
      feedType: string,
      getIdentifier: (t: Schema) => Identifier,
    ): Promise<Persistor<Schema, Identifier>>;
  }
// END ADDITION // 

export interface PersistorFactory {
  make<Schema extends Obj, Identifier extends Obj>(
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>>;
}

// ADDITION // 
export class PostgrePersistorFactory implements PgPersistorFactory {
  client: Client;
  constructor(client: Client) {
    this.client = client;
  }


  async make<Identifier extends Obj>(feedType: string) : Promise<Persistor<any, Identifier>> {
    if (feedType === "CPE") { 
      const persistor = new CPEPersistor(
        this.client,
      );
      return persistor;
    } else if (feedType === "CVE") {
      const persistor = new CVEPersistor(
        this.client,
      );
      return persistor;
    } else if (feedType === "MATCHING") {
      const persistor = new MatchingPersistor(
        this.client,
      );
      return persistor;
    } else {
      const persistor = new InfosPersistor(
        this.client,
      )
      return persistor;
    }
  }
}

export class CPEPersistor<
Schema extends CPESearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
  }

  async persistMany(items: Schema[]): Promise<number> {

    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 5;
      values.push(item.created_at, item.product, item.updated_at, item.version, item.cpe);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5})`;
    }).join(', ');
    const query = `
    INSERT INTO cots (created_at, name, updated_at, version, cpe)
    VALUES ${valuePlaceholders}
    ON CONFLICT (cpe) 
    DO UPDATE
    SET created_at=EXCLUDED.created_at,
    name=EXCLUDED.name,
    updated_at=EXCLUDED.updated_at,
    version=EXCLUDED.version;`;
    
    const res = await this.client.queryArray(query, values);
    return res["rowCount"]; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from cots where $1 = $2";
    let value;

    if ('cpe' in i) {
      column = 'cpe';
      value = i.cpe;
    }
    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }
}

export class MatchingPersistor<
Schema extends MATCHINGSearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
    
  }

  async persistMany(items: Schema[]): Promise<number> {

    // Start by adding to table matchings
    const values: any[] = [];
    const valuePlaceholders: string[] = [];
    items.map(async (item) => {
      // We handle matchings
      values.push(item.criteria, item.matchCriteriaId, item.created, item.lastModified, item.cpeLastModified, item.status);
      valuePlaceholders.push(`($${values.length - 5}, $${values.length - 4}::uuid, $${values.length - 3}, $${values.length - 2}, $${values.length - 1}, $${values.length})`);
    })
    
    const query = `
    INSERT INTO matchings (criteria, uuid, created, last_modified, cpe_last_modified, status)
    VALUES ${valuePlaceholders.join(', ')}
    ON CONFLICT (uuid) 
    DO UPDATE SET
    criteria=EXCLUDED.criteria, created=EXCLUDED.created, last_modified=EXCLUDED.last_modified, cpe_last_modified=EXCLUDED.cpe_last_modified, status=EXCLUDED.status;`;
    let persistCounter = items.length;
    const res = await this.client.queryArray(query, values);
    if (res["rowCount"] != persistCounter) {
      console.log("!!!!!!!!!!!!!!-------MATCHINGS-----!!!!!!!!!!!!!!\nDifference between what should have been added and what was added.\n" + res["rowCount"] + " is what was added and " + persistCounter + " is what should have been added.\n!!!!!!!!!!!!!!------------!!!!!!!!!!!!!!");
    }
    
    const persistMatchesCounter = await this.persistMatches(items);

    return (persistCounter+persistMatchesCounter);
    
  }
  
  async persistMatches(items: Schema[]): Promise<number> {
    
    let valuesMatchings: any[] = [];
    let valueMatchPlaceholders: string[] = []; 
    let cpe_matches_counter = 0;
    
    for (const item of items ){
      // We handle cpe_matches
      if (item.matches != undefined) {
        for (const cpe of item.matches) { 
          // Make sure that we really have a cpeName and not an empty cpe
          if (cpe.cpeName.length > 0) {
            // We may overload the query so we stop at 32000 entries
            if ((valuesMatchings.length/2) > 31998) {
              const returnCount = await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
              cpe_matches_counter += returnCount;
              valuesMatchings = [];
              valueMatchPlaceholders = [];
            }
            if (item.matchCriteriaId !== undefined && cpe.cpeName !== undefined) {
              valuesMatchings.push(item.matchCriteriaId, cpe.cpeName);
              valueMatchPlaceholders.push(`($${valuesMatchings.length - 1}::uuid, $${valuesMatchings.length})`);
            } else {
              console.log('We got an issue with an item :');
              console.log(item);
              console.log(cpe);
            }
          }
        }
      }
    }
    if (valueMatchPlaceholders.length > 0) {
      const returnCount = await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
      cpe_matches_counter += returnCount;
    }
    return (cpe_matches_counter); // Number of insertions done
  } 


  // Function to make the request to persist the matchings based on values and placeholders
  async persistMatchings(placeholders, values): Promise<number> {
    const querymatch = `WITH ins (match_id, cpe) AS
    ( VALUES ${placeholders.join(', ')} )  
    INSERT INTO cpe_matches
    (matching_id, cpe_id) 
    SELECT 
    matchings.id, cots.id
      FROM ins 
        JOIN cots ON cots.cpe = ins.cpe
        JOIN matchings ON matchings.uuid = ins.match_id
      ON CONFLICT (matching_id, cpe_id) DO UPDATE SET matching_id=EXCLUDED.matching_id, cpe_id=EXCLUDED.cpe_id;`

    const res = await this.client.queryArray(querymatch, values);
    if (res["rowCount"] != (values.length)/2) {
      console.log("!!!!!!!!!!!!!!------CPE_MATCHES------!!!!!!!!!!!!!!\nDifference between what should have been added and what was added.\n" + res["rowCount"] + " is what was added and " + ((values.length)/2) + " is what should have been added.\n!!!!!!!!!!!!!!------------!!!!!!!!!!!!!!");
    }
    return res["rowCount"];
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from matchings where $1 = $2";
    let value;

    if ('match_id' in i) {
      column = 'match_id';
      value = i.match_id;
    }
    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }
}



export class CVEPersistor<
Schema extends BaseCVESearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
  }

  async persistMany(items: Schema[]): Promise<number> {
    let counter = 0; 
    counter += await this.persistCVETable(items);
    counter += await this.persistCVSS3(items);
    counter += await this.persistCVSS2(items);
    counter += await this.persistCVEVulnConf(items);

    return counter; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from cve where $1 = $2";
    let value;

    if ('name' in i) {
      column = 'name';
      value = i.name;
    }

    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }

  async persistCVETable(items: Schema[]) {
    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 7;
      values.push(item.cwe, item.last_modified, item.Modified, item.id, item.Published, item.summary, item.status);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6}, $${baseIndex + 7})`;
    }).join(', ');
    const query = `
    INSERT INTO cve (cwe,last_modified, modified, name, published, summary, status)
    VALUES ${valuePlaceholders}
    ON CONFLICT (name) 
    DO NOTHING;`;

    const res = await this.client.queryArray(query, values);
    return res["rowCount"]; // Number of insertions done

  }

  async persistCVSS3(items: Schema[])Â {
    let countInsertions = 0;

    const valuesVectors: any[] = [];
    const valuePlaceholdersVectors: string[] = [];
    items.map((item) => {
      if (item.cvss3 != undefined) {
        valuesVectors.push(item.exploitability3.attackcomplexity, item.exploitability3.attackvector, item.impact3.availability, item.impact3.confidentiality, item.impact3.integrity, item.exploitability3.privilegesrequired, item.exploitability3.scope, item.exploitability3.userinteraction, item.cvss3_vector);
        valuePlaceholdersVectors.push(`($${valuesVectors.length - 8}, $${valuesVectors.length - 7}, $${valuesVectors.length - 6}, $${valuesVectors.length - 5}, $${valuesVectors.length - 4}, $${valuesVectors.length - 3}, $${valuesVectors.length - 2}, $${valuesVectors.length - 1}, $${valuesVectors.length})`);
      }
    });
    if (valuesVectors.length > 0) {
      const queryVectors = `
      INSERT INTO cvss3_vector (attack_complexity, attack_vector, availability, confidentiality, integrity, privileges_required, scope, user_interaction, value) 
      VALUES ${valuePlaceholdersVectors.join(', ')}
      ON CONFLICT (value)
      DO NOTHING;
      `


    
      const resVectors = await this.client.queryArray(queryVectors, valuesVectors);
      countInsertions += resVectors["rowCount"];
      
      const valuesMarks: any[] = [];
      const valuePlaceholdersMarks: string[]= [];
      items.map((item) => {
        if (item.cvss3 != undefined) {
          valuesMarks.push(item.cvss3, item.exploitabilityScore3, item.impactScore3, item.id, item.cvss3_vector);
          valuePlaceholdersMarks.push(`($${valuesMarks.length - 4}::real, $${valuesMarks.length - 3}::real, $${valuesMarks.length - 2}::real, $${valuesMarks.length - 1}, $${valuesMarks.length})`);
        }
      });
    
      const queryMarks = `
      WITH ins (cvss, exploitability_score, impact_score, cveName, cvss3_vector) AS
      (VALUES ${valuePlaceholdersMarks.join(', ')})
      INSERT INTO cvss3_mark (cvss, exploitability_score, impact_score, cve_id, vector_id)
      SELECT 
      ins.cvss, ins.exploitability_score, ins.impact_score, cve.id, cvss3_vector.id
      FROM ins 
      JOIN cve ON cve.name = ins.cveName
      JOIN cvss3_vector ON cvss3_vector.value = ins.cvss3_vector
      ON CONFLICT (cve_id) DO UPDATE SET
      cvss=EXCLUDED.cvss,
      exploitability_score=EXCLUDED.exploitability_score,
      impact_score=EXCLUDED.impact_score,
      vector_id=EXCLUDED.vector_id;
      `
      const resMarks = await this.client.queryArray(queryMarks, valuesMarks)
      countInsertions += resMarks["rowCount"];
    
    }
    return countInsertions;
  }
  async persistCVSS2(items: Schema[]) {
    let countInsertions = 0;

    const valuesVectors: any[] = [];
    const valuePlaceholdersVectors: string[] = [];
    items.map((item) => {
      if (item.cvss != undefined) {
        valuesVectors.push(item.access.complexity, item.access.vector, item.impact.availability, item.impact.confidentiality, item.impact.integrity, item.access.authentication, item.cvss_vector);
        valuePlaceholdersVectors.push(`($${valuesVectors.length - 6}, $${valuesVectors.length - 5}, $${valuesVectors.length - 4}, $${valuesVectors.length - 3}, $${valuesVectors.length - 2}, $${valuesVectors.length - 1}, $${valuesVectors.length})`);
      }
    });
    if (valuesVectors.length > 0) {
      const queryVectors = `
      INSERT INTO cvss2_vector (attack_complexity, attack_vector, availability, confidentiality, integrity, authentication, value) 
      VALUES ${valuePlaceholdersVectors.join(', ')}
      ON CONFLICT (value)
      DO NOTHING;
      `


    
      const resVectors = await this.client.queryArray(queryVectors, valuesVectors);
      countInsertions += resVectors["rowCount"];
      
      const valuesMarks: any[] = [];
      const valuePlaceholdersMarks: string[]= [];
      items.map((item) => {
        if (item.cvss3 != undefined) {
          valuesMarks.push(item.cvss, item.exploitabilityScore, item.impactScore, item.id, item.cvss_vector);
          valuePlaceholdersMarks.push(`($${valuesMarks.length - 4}::real, $${valuesMarks.length - 3}::real, $${valuesMarks.length - 2}::real, $${valuesMarks.length - 1}, $${valuesMarks.length})`);
        }
      });
    
      const queryMarks = `
      WITH ins (cvss, exploitability_score, impact_score, cveName, cvss_vector) AS
      (VALUES ${valuePlaceholdersMarks.join(', ')})
      INSERT INTO cvss2_mark (cvss, exploitability_score, impact_score, cve_id, vector_id)
      SELECT 
      ins.cvss, ins.exploitability_score, ins.impact_score, cve.id, cvss2_vector.id
      FROM ins 
      JOIN cve ON cve.name = ins.cveName
      JOIN cvss2_vector ON cvss2_vector.value = ins.cvss_vector
      ON CONFLICT (cve_id) DO UPDATE SET
      cvss=EXCLUDED.cvss,
      exploitability_score=EXCLUDED.exploitability_score,
      impact_score=EXCLUDED.impact_score,
      vector_id=EXCLUDED.vector_id;
      `
      const resMarks = await this.client.queryArray(queryMarks, valuesMarks)
      countInsertions += resMarks["rowCount"];
    
    }
    return countInsertions;
  }

  async persistCVEVulnConf(items: Schema[]) {
    let counter = 0;
    let values: any[] = [];
    let valuePlaceholders: string[] = [];
    for (const item of items) {
      for (const match of item.matches) {
        if (values.length/2 >= 32000) {
          let res = await this.persistConfs(values, valuePlaceholders);
          counter = counter + res;
          values = [];
          valuePlaceholders = [];
        }
        values.push(match.matchCriteriaId, item.id);
        valuePlaceholders.push(`($${values.length - 1}::uuid, $${values.length})`);
      }
    };
    if (values.length > 0) {
      counter += await this.persistConfs(values, valuePlaceholders);
    }
    return counter;
  }

  async persistConfs(values, valuePlaceholders) {
    const query = `WITH ins (match_uuid, cve_name) AS
    ( VALUES ${valuePlaceholders.join(', ')} )  
    INSERT INTO cots_cves
    (cots_id, cves_id) 
    SELECT 
    cpe_matches.cpe_id as cots_id, cve.id as cves_id
      FROM ins 
        JOIN cve ON cve.name = ins.cve_name
        JOIN matchings ON matchings.uuid = ins.match_uuid
        JOIN cpe_matches ON cpe_matches.matching_id = matchings.id
      ON CONFLICT (cots_id, cves_id) DO NOTHING;`;

    const res = await this.client.queryArray(query, values);

    return res["rowCount"]
  }
}
  // END ADDITION //

export class InfosPersistor<
Schema extends UpdateSchema,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
    
  }
  async persistMany(items: Schema[]): Promise<number> {
    console.log("This should not ever be called")
    return 0; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  async persistOne(item: Schema): Promise<boolean> {
    const res = await this.client.queryObject(`UPDATE updates SET last_update='${formatDate(item.last_update)}' where id=${item.id}`);
    return res.rows.length;
  }

  close(): Promise<void> {
    return this.client.end();
  }

  async findOne(i: Identifier): Promise<Schema | undefined> {
    const res = await this.client.queryObject(`select last_update from updates where name = ${i}`);
    return res.rows[0];
  }
}
